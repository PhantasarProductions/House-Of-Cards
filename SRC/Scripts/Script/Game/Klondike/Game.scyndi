// License Information:
// House Of Cards
// Klondike Script
// 
// 
// 
// (c) Jeroen P. Broks, 2024
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 
// Please note that some references to data like pictures or audio, do not automatically
// fall under this licenses. Mostly this is noted in the respective files.
// 
// Version: 24.03.20
// End License Information
Script

#use "Libs/SCI/Sys"
#use "Libs/SCI/GINIE"
#use "Libs/SCI/Graphics"

#use "Libs/XMath"
#use "Libs/Stacker"

#use "Script/Use/Lnk/Deck"
#use "Script/Use/Lnk/Card"
#use "Script/Use/Gen/Muis"
#use "Script/Use/Gen/Sound"
#use "Script/Use/Gen/RText"
#use "Script/Use/Gen/Config"
#use "Script/Use/Gen/GameFeatures"


ReadOnly Var PPP = LoadNewImage("Script/Game/Spider/PointPackages.png","SPIDER_PPP") // Why not re-use stuff, eh?


plua KLO_CardSize = Lua.Scyndi.Class.CardSize.FromW(Graphics.Width div 11)
plua KLO_Card
plua KLO_Draw
plua KLO_Disc // Not the right word but by lack of a better term
plua KLO_Clear
plua KLO_RowNodes
plua KLO_Row
plua KLO_Deck
plua KLO_DrawPile
Plua KLO_DiscPile
plua KLO_DiscShow = {}
plua KLO_Config = GINIE.Obtain("CONFIG::KLONDIKE")
plua KLO_Icon = LoadNewImage("Script/Game/Klondike/Klondike.png","KLONDIKE_ICON")
plua KLO_DragCards = nil
 

Int KLO_State = 0
// 0 = Playing
// 1 = Win
// 2 = Auto-Solving

int hue = os.time()

Class CardNode
	Static Int Num
	Static Number Deg = os.time() % 360
	Static Var First
	Static Var Last
	Var Next
	ReadOnly Int ID
	ReadOnly Int X
	ReadOnly Int Y
	Static Get Int W;Return KLO_CardSize.W; End
	Static Get Int H;Return KLO_CardSize.H; End

		
	Void Draw()
		Deg = Deg + 0.01
		SetColor(100,100,100)
		SetAlpha(math.floor(math.abs(XMath.Sin(Deg+(ID*10))*255)))
		Rect(X,Y,KLO_CardSize.W,KLO_CardSize.H)
	End
	
	Static Void DrawAll()
		For c in Each_Chain(First)
			c.Draw()
		End
		SetAlpha(255)
	End
		
	Constructor(Int _X,Int _Y)
		ID = Num;Num++
		First = First || Self
		if (Last); Last.Next = Self; End
		Last = Self
		X = _X
		Y = _Y
		CSayF("Card Node created at (%04d, %04d)",X,Y)
	End
End


Class KlondikeCard
	Int GoToX
	Int GoToY
	Int X
	Int Y
	Get Int W;Return KLO_CardSize.W; End
	Get Int H;Return KLO_CardSize.H; End
	Bool Visible = False
	Var Card
	
	Void Go(V1,V2,V3)
		switch(lua.type(V1))
			case "table";  GotoX = V1.X + (V2 || 0); GotoY = V1.Y + (V3 || 0);
			case "number"; GotoX = V1; GotoY=V2
			case "nil";
			default; Lua.error("Illegal card constructor") 
		end
	End
	
	Void Draw()
		if X>GoToX; X = x - math.max(1,math.abs(X-GotoX) div 10); End
		if Y>GoToY; Y = Y - math.max(1,math.abs(Y-GotoY) div 10); End
		if X<GoToX; X = x + math.max(1,math.abs(GotoX-X) div 10); End
		if Y<GoToY; Y = Y + math.max(1,math.abs(GotoY-Y) div 10); End
		If Visible
			KLO_Card.DrawCard(X,Y,Card.CardSuit,Card.CardValue)
		Else
			KLO_Card.DrawBack(X,Y)
		End	
	End
	
	Constructor(V1,V2,V3)
		switch math.random(1,4)
			case 1; X = graphics.width +math.random(1,1000); Y = math.random(-1000,Graphics.Height+1000)
			case 2; X =                -math.random(1,1000); Y = math.random(-1000,Graphics.Height+1000)
			case 3; Y = graphics.height+math.random(1,1000); X = math.random(-1000,Graphics.Width +1000)
			case 4; Y =                -math.random(1,1000); X = math.random(-1000,Graphics.Width +1000)
			default; X = -1000; Y=-1000 // Cash prevention. This is only cosmetic after all!
		end
		Self.Go(V1,V2,V3)
	End
End

Init
	KLO_Card = KLO_CardSize.Bind()

	// Piles
	KLO_Draw = new CardNode(5,5)
	KLO_Disc = new CardNode(10+KLO_CardSize.W,5)
	
	// Cleared
	KLO_Clear = {}
	KLO_Clear[0] = New CardNode( 5               ,Graphics.Height-math.floor(KLO_CardSize.H * 2.5))
	KLO_Clear[1] = New CardNode(10+KLO_CardSize.W,Graphics.Height-math.floor(KLO_CardSize.H * 2.5))
	KLO_Clear[2] = New CardNode( 5               ,Graphics.Height-math.floor(KLO_CardSize.H * 1.25))
	KLO_Clear[3] = New CardNode(10+KLO_CardSize.W,Graphics.Height-math.floor(KLO_CardSize.H * 1.25))
	KLO_RowNodes = {}
	For i=0,6
		int x
		x = Graphics.Width- ((KLO_CardSize.W*1.25)*(7-i))
		KLO_RowNodes[i] = New CardNode(x,10)
	End
End

Global Bool GAMEFEATURES_SAVEEXIT_ALLOW(); Return KLO_State==0; End

Get Bool Dragging
	If !KLO_DragCards		
		Return False
	ElIf !MDL
		//Int AtRow = -1
		For Ri,RA in ipairs(KLO_Row)
			plua RN;RN=KLO_RowNodes[Ri]
			   // Mouse position          Not the same row            // Kings on an empty row                            // Other card value                                                   // Red is not black and vice versa
			If MX>RN.X && MX<RN.X+RN.W && ri!=KLO_DragCards.Row && ( (KLO_DragCards[0].Card.CardValue==13 && Len(RA)==0) || (Len(RA)>0 && KLO_DragCards[0].Card.CardValue==RA[Len(RA)-1].Card.CardValue-1 && KLO_DragCards[0].Card.CardSuit % 2!=RA[Len(RA)-1].Card.CardSuit % 2)) 
				For di,dc in ipairs(KLO_DragCards)
					RA[Len(RA)]=DC
					SFX("SLIDE")
				End
				// Two loops to prevent conflicts
				if KLO_DragCards.Row==-1
					KLO_DiscPile.Pop()
				Else 
					For di,dc in ipairs(KLO_DragCards)
						KLO_Row[KLO_DragCards.Row][di+KLO_DragCards.Card] = nil
					End
				End
				KLO_DragCards = nil
				Return False
			End
		End
		if KLO_DragCards.Row==-1
			KLO_DragCards[0].GoToX = KLO_Disc.X
			KLO_DragCards[0].GoToY = KLO_DragCards.OY
		End
		KLO_DragCards = nil
	Else
		For di,dc in ipairs(KLO_DragCards)
			DC.GotoX = MX - (DC.W div 2)
			DC.GotoY = MY + (di*45)
			DC.X = DC.GotoX
			DC.Y = DC.GotoY
		End
	End
	Return True 
End

Void Deal()
	int dp=0
	KLO_Row = {}
	For i2=0,6		
		For i1=i2,6
			KLO_Row[i1] = KLO_Row[i1] || {}
			CSayF("Dealing card on row %d:%d",i1,i2)
			plua crd;crd = new KlondikeCard(KLO_RowNodes[i1])
			KLO_Row[i1][i2] = crd
			crd.Card = KLO_Deck[dp]
			dp++
		End
	End
	KLO_DrawPile = New Stack()
	KLO_DiscPile = New Stack()
	For i=51,dp,-1
		plua crd;crd = new KlondikeCard(KLO_Draw)
		crd.Card = KLO_deck[i]
		KLO_DrawPile.Push(crd)
	End
End

Void DrawCards()
	SetColor(255,255,255,255)
	// Rows on the table
	For ri,ra in ipairs(KLO_Row)
		int mody=0
		For ci,ca in ipairs(ra)
			If (!Dragging)
				ca.Go(KLO_RowNodes[ri],0,mody)
			End
			ca.Visible = ca.Visible || ci==len(ra)-1
			ca.Draw()
			If ca.Visible
				Mody=Mody+31
				If (!Dragging) && MX>ca.X && MY>ca.Y && MX<ca.X+ca.W && MY<ca.Y+ca.H
					PPP.Stretch(ca.X-64,ca.Y-64,64,64)
					If MDL 
						KLO_DragCards = { ["Row"]=ri, ["Card"]=ci }
						Int di=0
						Repeat
							KLO_DragCards[len(KLO_DragCards)]=ra[di+ci]
							di++
						LoopWhile ra[di+ci]
					End
				End
			Else
				Mody=Mody+5
			End
		End
	End
	// Draw Pile
	If KLO_DrawPile.Have
		KLO_Card.DrawBack(KLO_Draw.X,KLO_Draw.Y)
		If MX>KLO_Draw.X && MY>KLO_Draw.Y && MX<KLO_Draw.X+KLO_Draw.W && MY<KLO_Draw.Y+KLO_Draw.H 
			PPP.Stretch(0,0,64,64)
			If ML
				SFX("SLIDE")
				For k in Each(KLO_DiscPile.Array); k.GotoY=KLO_Disc.Y; k.Y = KLO_Disc.Y; End 				
				For i=0,KLO_CONFIG.INTVALUE("CONFIG","FROMPILE")-1
					// Seems double, but the 3 card draw needs it.
					If KLO_DrawPile.Have
						plua dcard = KLO_DrawPile.Pop()
						KLO_DiscPile.Push(dcard)
						dcard.x = KLO_Draw.X
						dcard.y = KLO_Draw.Y
						dcard.gotox = KLO_Disc.X
						dcard.gotoy = KLO_Disc.Y + (i*40)
						dcard.visible = true
						//KLO_DiscShow[i] = dcard
					End					
				End
				KLO_DiscShow = KLO_DiscPile.Array
			End
		End
	Else
		If (!Dragging) && MX>KLO_Draw.X && MY>KLO_Draw.Y && MX<KLO_Draw.X+KLO_Draw.W && MY<KLO_Draw.Y+KLO_Draw.H
			PPP.Stretch(0,0,64,64)
			If ML
				SFX("SLIDE")
				KLO_DrawPile = New Stack()
				While KLO_DiscPile.have
					plua dcard = KLO_DiscPile.Pop()
					dcard.visible=0
					KLO_DrawPile.Push(dcard)
				End
				KLO_DiscPile = New Stack()
				KLO_DiscShow = {}
			End
		End
	End
	// Disc pile
	For i=len(KLO_DiscShow)-1,0,-1
		KLO_DiscShow[i].Draw()		
	End
	plua top = KLO_DiscShow[0]
	If top && MX>KLO_Disc.x && MY>top.y && MX<top.x+top.w && MY<top.y+top.h && (!Dragging)
		PPP.Stretch(top.x-(top.w div 2),0,64,64)
		if MDL
			KLO_DragCards = { ["Row"]=-1, ["Card"]=0,[0]=top, ["OY"]=top.gotoY }
		End
	End
End
	
Global Void GameNew(String CShuffle="")
	GameFeatures.ShuffleTag="DECK_Klondike"
	If CShuffle!=""
		Lua.error("Loading shuffles not yet supported")
	Else
		Klo_Deck = Deck.Shuffle("DECK_KLONDIKE",KLO_Config.Value("Shuffle","Shuffle"))
	End
	Deal()
End

Global Void MainFlow()
	hue = (hue+1)%360
	SetColor(255,255,255,255)
	DrawBackground()
	CardNode.DrawAll()
	DrawCards()
	KLO_Icon.Stretch(Graphics.Width-64,Graphics.Height-64,64,64)
	GameFeatures.Button()
	ShowMouse()
End